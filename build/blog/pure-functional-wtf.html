<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0">
    <meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning.">
    <title>Pure Functional WTF | r-wos.org</title>
    <style>
    * { line-height: 140%; }
    body { margin:15px auto; max-width:40em; padding: 0 1em; }
    body { background: lightcyan; }
    nav, main, aside { background: white; border: 4px ridge black; padding: 8px 1em; margin: 8px 0; }
    nav { background: lightyellow; }
    h1 { text-align: center; color: rebeccapurple; }
    time { background: yellow }
    {% include blink.css %}
    </style>
  </head>
  <body>
    <nav>
      <img style="vertical-align: middle" src="/media/disk.gif">
      <a href="/">Home</a> -
      <a href="/blog">Blog</a> -
      <a href="/feed.xml">RSS</a> -
      <a href="/hacks">Hacks</a> -
      <a href="/about">About</a>
    </nav>
    <main>
      <h1>Pure Functional WTF</h1>
      <p><b><time datetime="2011-10-23 00:00:00 &#43;0000">2011-10-23 00:00:00 &#43;0000</time></b></p>
      <p>I watched a couple of talks from Rich Hickey recently.
(To be precise: <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">this talk</a>
and <a href="http://www.infoq.com/presentations/Simple-Made-Easy">this one</a>.)</p>
<p>He is the creator of <a href="http://clojure.org">Clojure</a>,
a Lisp for the JVM and the CLI (the .NET system).  Well, actually,
Clojure is not only <em>some</em> Lisp, but a more modern, more functional Lisp dialect.</p>
<p>Clojure is based on immutable types, like other pure-functional languages.</p>
<p>This was a foreign concept for me. And it doesn't seem very helpful at first.
You can't change things. You have to produce a new version, with the &quot;changes&quot;
included. Now, clojure makes this faster than it sounds, using some heavy
trie wizardry (yes, <a href="http://en.wikipedia.org/wiki/Trie">trie</a>,
not tree) - but that's not the point.</p>
<p>The point is - that whole concept makes sense. You can stop worrying about
the state of a data structure. The thing you got will never change. It can't.
It's save to dereference, and it always will be.</p>
<p>Additionally, and derived from that, everything becomes time-independent.
As long as you apply the same functions in the same order on the same data,
you will always get the same result.</p>
<p>That's functional programming and that's all fun and games. I can easily see
that this works great for any sort of compiler or translator or programs of
that kind.</p>
<p>But it doesn't really work for processes; for programs where you <em>want</em> changes
over time, or for any kind of I/O.</p>
<p>And that is the point where it gets tricky. Now you've got to manage time.
And you've got to manage side-effects.
That's where things like &quot;monads&quot; enter the stage.</p>
<p>Rich Hickey talked about the difference between &quot;simple&quot; and &quot;easy&quot; - and
doing I/O via monads is one of the things, where - for me - it becomes
too hard to do the simple.</p>
<p>I just don't grok it. When I read sentences like this:</p>
<blockquote>
<p>An additive monad is a monad endowed with a monadic zero and an
operation (called mplus) satisfying the monoid laws, with the monadic zero
as unit. The operation has type M t -&gt; M t -&gt; M t (where M is the monad constructor
and t is the underlying data type), satisfies the associative law and has the
zero as both left and right identity. (Thus, an additive monad is also a monoid.)</p>
</blockquote>
<p>my brain switches into &quot;overload&quot; mode. I get a SIGSEGV from only <em>trying</em> to
understand what this might be about.</p>
<p>How can simple things be so hard?</p>
<p>In some regards, this reminds me of my first encounter with object-oriented programming.
I thought &quot;WTF is this about? Why can't they just, you know, <em>program</em> like
normal people?&quot;. But I <em>did</em> understand OOP, eventually.  I don't know how,
but one day the light bulb went on.</p>
<p>I really hope that happens with monads, too.</p>
<p>This cannot not be as hard as it looks, right?</p>

    </main>
  </body>
</html>
