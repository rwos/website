<p>Working with strings is painful in C. I knew that.</p>
<p>But I have completely forgotten, <em>how</em> brain-shattering painful it is.</p>
<p>I guess it's common knowledge, but let's recap some of the issues:</p>
<ul>
<li><code>strlen()</code> <em>does</em> give you the string's length - but only in a very strict sense. It does <em>not</em> give you the string's size. That would be one byte more.</li>
<li>A simple <code>strlen()</code> call on garbage (that is, a perfect valid string but without the terminating NUL byte, for example) will very likely run until your process segfaults.</li>
<li><code>strcpy()</code>, which copies a string to another location, absolutely needs a destination that must be of at least the source's size and a source that is NUL-terminated. So you'll have to check for that. Oh, and yes, <code>strcpy()</code> will happily wreck total havoc if you fail to provide it, of course.</li>
<li><code>strncpy()</code> is somewhat better, using an additional parameter that limits the bytes copied. That eliminates the &quot;the destination must be of some uncertain size&quot; problem, but introduces new problems in return: If there is no NUL byte among the n bytes that you want to have copied, the destination will not be NUL-terminated. That is, <em>it will be no string</em>. See above for what that means in C. So, you'll have to include checks, tooÂ  - which completely defeats the purpose of choosing <code>strncpy()</code> over the faster <code>strcpy()</code>.</li>
<li>Because of the very nature of &quot;strings&quot; in C, <code>strlen()</code> is of linear time complexity, making string concatenations, for example, much slower than needed.</li>
<li>etc.</li>
</ul>
<p>And yes, I know that those pitfalls (and many more) are well-documented in the man pages. I know that C strings are of unmatched space efficiency. I know that it was the only possible way to get unlimited strings on machines with a 64k core.</p>
<p>And it's not that it was <em>impossible</em> to work with standard strings in C. It's just <em>much harder than it needs to be</em>. And much more dangerous.</p>
<p>It's like [insert crazy rhetoric figure, comparing working with C strings with [doing normal stuff] using [highly dangerous equipment]].</p>
<p>Or something like that.</p>
<p>PS: Just in case this isn't clear to everyone: C is a programming language. In fact, C is a pretty <em>good</em> programming language. I like it very much. It's a piece of cake to implement better strings in C, custom made for your needs. Only the string implementation of the standard library is, well, a bit <em>unpleasant</em> to use.</p>
