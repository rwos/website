<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0">
    <meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning.">
    <title>Given When Then | r-wos.org</title>
    <style>

.terminal .clipboard {
 position:absolute;
 bottom:0;
 left:0;
 opacity:0.01;
 filter:alpha(opacity = 0.01);
 filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0.01);
 width:2px;
}
.cmd > .clipboard {
 position:fixed;
}
.terminal {
 padding:10px;
 position:relative;
 overflow:hidden;
}
.cmd {
 padding:0;
 margin:0;
 height:1.3em;
}
.terminal .terminal-output div div,
.terminal .prompt {
 display:block;
 line-height:14px;
 height:16px;
}
.terminal {
 font-family:FreeMono,monospace;
 color:#33dd33;
 background-color:#000f00;
 font-size:14px;
 line-height:16px;
}
.terminal .terminal-output div span {
 display:inline-block;
}
.terminal .cmd span {
 display:inline-block;
}
.terminal .cmd span.inverted {
 background-color:#33dd33;
 color:#000f00;
}
.terminal .terminal-output div div::-moz-selection,
.terminal .terminal-output div span::-moz-selection {
 background-color:#33dd33;
 color:#000f00;
}
.terminal .terminal-output div div::selection,
.terminal .terminal-output div span::selection,
.terminal .cmd > span::selection,
.terminal .prompt span::selection {
 background-color:#33dd33;
 color:#000f00;
}
.terminal .terminal-output div.error,
.terminal .terminal-output div.error div {
 color:#33dd33;
}
.tilda {
 position:fixed;
 top:0;
 left:0;
 width:100%;
 z-index:1100;
}
.clear {
 clear:both;
}
.terminal a {
 color:#ccff66;
}
.terminal a:hover {
 color:#ccff66;
}
body {
 font-family:Helvetica,Arial,sans-serif;
 font-size:11pt;
 line-height:1.5em;
 padding:0.5em;
 margin:0em;
 color:#33dd33;
 background-color:#000f00;
}
main {
 max-width:50em;
 margin-left:auto;
 margin-right:auto;
}
#footer,
#footer * {
 text-align:center;
 font-size:9pt;
 color:#226622;
}
#footer > a {
 color:#226622;
 text-decoration:underline;
}
h1,
h2,
h3,
h4 {
 color:#66ff66;
 line-height:1em;
 text-align:center !important;
 font-family:Georgia,serif;
 font-weight:normal;
}
a {
 color:#ccff66;
 text-decoration:none;
}
a img {
 display:inline-block;
 border:none;
}
a:hover {
 color:#000f00 ! important;
 background-color:#ffff00;
 border-radius:5px 5px 5px 5px;
 box-shadow:0px 0px 5px 4px #ffff00;
}
a:visited {
 color:#aaaa00;
}
nav {
 font-size:10pt;
 text-align:center;
}
.header {
 text-align:center !important;
}
h1 {
 font-size:16pt;
 border-top:1pt solid #66aa66;
 padding-top:0.25em;
 margin-top:1em;
 display:inline-block;
}
hr {
 border-style:none;
 width:50%;
 height:0pt;
 border-top:2pt solid #339933;
}
dl {
 display:inline-block;
}
dt {
 padding-top:1em;
 font-size:90%;
}
dt:first-letter {
 font-size:110%;
}
dd {
 padding-left:0.5em;
}
dd .descr {
 margin:0pt;
 margin-left:3em;
 margin-bottom:0.5em;
 padding 0pt;
}
.block {
 margin:1em;
 padding:4em;
 padding-top:1.5em;
 padding-bottom:2em;
 border-top:2pt solid #339933;
 border-bottom:2pt solid #339933;
 border-radius:2em;
 text-align:center;
}
.block * {
 text-align:left;
}
input[type=text],
textarea {
 color:#33dd33;
 background-color:#003f00;
 border:2pt solid #003f00;
 border-radius:0.25em;
}
input[type=text]:focus,
textarea:focus {
 border-top:2pt solid #339933;
 border-bottom:2pt solid #339933;
}
input[type=button],
input[type=submit] {
 color:#33dd33;
 background-color:#003f00;
 border-radius:0.25em;
 border:2pt solid #339933;
}
input[type=button]:hover,
input[type=submit]:hover {
 color:#000f00;
 background-color:#ffff00;
 border:2pt solid #ffff00;
 box-shadow:0px 0px 5px 4px #ffff00;
}
.nav-prev {
 float:left;
 font-size:small;
}
.nav-next {
 float:right;
 font-size:small;
}
@media (max-width:500px) {
 .block {
  padding-left:0em;
  padding-right:0em;
 }
 .nav-prev,
 .nav-next {
  float:none;
 }
}
 
 
    </style>
  </head>
  <body>
    <nav>
      <img style="vertical-align: middle" src="/media/disk.gif">
      <a href="/">Home</a> -
      <a href="/blog/">Blog</a> -
      <a href="/feed.xml">RSS</a> -
      <a href="/hacks/">Hacks</a> -
      <a href="/about">About</a>
    </nav>
    <main>
      <h1>Given When Then</h1>
      <p><b><time datetime="2013-10-27 00:00:00 &#43;0000 &#43;0000">2013-10-27 00:00:00 &#43;0000 &#43;0000</time></b></p>
      <p><a href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a> is a hack.</p>
<p>Gherkin is the &quot;language&quot; (I'll justify the use of scare-quotes in a minute)
used by the <a href="https://github.com/cucumber/cucumber">Cucumber</a> test framework.
Or, if you're using PHP, the language behind the PHP port <a href="http://behat.org/">behat</a>.</p>
<p>Tests usually look something like this (example lifted straight from cucumber's docs):</p>
<pre><code>Feature: Serve coffee
  In order to earn money
  Customers should be able to 
  buy coffee at all times

  Scenario: Buy last coffee
    Given there are 1 coffees left in the machine
    And I have deposited 1$
    When I press the coffee button
    Then I should be served a coffee
</code></pre>
<p>Which <em>is</em> very nice. Having tests that are as easily readable as this
is obviously fantastic!</p>
<p>What is not nice is how it's implemented. What is even less nice, is how it's
sold as a &quot;business readable, domain specific language&quot;. I can live very well
with crude hacks, as long as the README states &quot;it's a crude hack&quot;. Glancing
over obvious limitations in exchange for marketing slogans bothers me, however.
Among programmers, we should be honest first.</p>
<h2 id="intro">intro</h2>
<p>Let's step through the test above:</p>
<pre><code>Feature: Serve coffee
  In order to earn money
  Customers should be able to 
  buy coffee at all times
</code></pre>
<p>This whole block is just a comment and subsequently ignored. You have to
have one of those at the top of your files, and the block below <code>Feature</code> has
to be indented, however.</p>
<pre><code>  Scenario: Buy last coffee
</code></pre>
<p>Another comment. Now comes the actual executable code:</p>
<pre><code>Given there are 1 coffees left in the machine
And I have deposited 1$
When I press the coffee button
Then I should be served a coffee
</code></pre>
<p>Every line here is a &quot;step&quot;, and every step does something.</p>
<h2 id="assertions-and-instructions">assertions and instructions</h2>
<p>Even thought there are semantic differences between sentences beginning with
with <code>Given</code>, <code>When</code>, and <code>Then</code> in English, they are all the same thing in Gherkin.</p>
<p>Suppose the first sentence</p>
<pre><code>Given there are 1 coffees left in the machine
</code></pre>
<p>sets up the machine to have 1 coffees [sic!] left. You start to run into problems
once you now write a different test where the <em>outcome</em> should be that the
machine has one coffee left. Say, something like this:</p>
<pre><code>Given there are 2 coffees left in the machine
When I order one coffee
Then there are 1 coffees left in the machine.
</code></pre>
<p>Perfectly reasonable for a human, but for Gherkin this translates to:</p>
<pre><code>set up the machine to have 2 coffees left
order one coffee
set up the machine to have 1 coffee left
</code></pre>
<p>Which is not only not right, it's not even wrong. This test will
run and it will run <em>successfully</em> every time.</p>
<p>What Gherkin wants you to write is something like this:</p>
<pre><code>Given there are 2 coffees left in the machine
When I order one coffee
Then there should be 1 coffees left in the machine.
</code></pre>
<p>So that the programmers can implement the &quot;there should be&quot; sentence as an assertion,
and the &quot;there are&quot; sentence as a instruction. Why is this difference not
handled via the <code>Given</code>/<code>Then</code> keywords? Who knows.</p>
<p>This minimalism/stupidity in Gherkin's approach to parsing results in a
programming language with extremely low orthogonality. In fact, there's none at
all. If you come across a step like</p>
<pre><code>Given there are 1 coffees left in the machine
</code></pre>
<p>this does <em>not</em> guarantee at all that</p>
<ul>
<li>there's a step <code>Given there are 2 coffees left in the machine</code></li>
<li>there's a step <code>Given there are 1 cappuccinos left in the machine</code></li>
<li>there's a step <code>Then there should be 1 coffees left in the machine</code></li>
<li>and so on</li>
</ul>
<p>I think this is pretty confusing, <em>especially</em> for non-programmers.
Also, depending on how you write your regexps, the step above is distinct from
all of the following:</p>
<ul>
<li>Given there are 1 coffees  left in the machine</li>
<li>Given there are 1 coffees left in the machine.</li>
<li>Given there are 1 coffees left in the machine!</li>
<li>Given there are 1 coffee left in the machine</li>
<li>Given there is 1 coffee left in the machine</li>
<li>Given there is one coffee left in the machine</li>
<li>Given there are 1 coffees left</li>
<li>and so on</li>
</ul>
<p>This is easily traceable back to the simplistic implementation, but that doesn't
help anyone. Gherkin is aimed at non-technical folk - and it's syntactically
<em>less</em> forgiving than JavaScript! In terms of human-friendliness of the
syntax it's comparable to the older fixed-format versions of FORTRAN.</p>
<p>In other words: Gherkin is (or can be) nice to read, but it's <em>extremely</em>
unfriendly to write.</p>
<h2 id="2-problems">2 problems</h2>
<p>Let's talk about the implementation. Gherkin is regexp-based
<strike>because that's an absolutely reasonable choice for parsing a natural language</strike>.</p>
<p>So, for every &quot;step&quot;, you have a regexp with some code behind it, that implements
this step. It looks something like this (in cucumber, behat is a bit more verbose):</p>
<pre><code>Given /I have deposited (\d+)\$/ do |n|
    @machine.deposit(n)
end
</code></pre>
<p>In other words: there is no Gherkin language. At all. Gherkin is a lexical scanner,
nothing more. The parser (regexps) and evaluator (associated code) is solely in
your hands to implement. And because Gherkin limits you to per-line regexps,
the resulting Gherkin-based DSL is <em>less</em> capable than pretty much anything
you could've come up with yourself.</p>
<p>In behat at least (I assume it's the same in cucumber), there's also no way to
stack regexps. Every step has to match exactly <em>one</em> regexp.  What that means
is that you can't special-case steps, and you can't override them. (Well, you
can, but it's extremely hacky).</p>
<p>There are other limitations: It's not possible to use the &quot;language&quot; itself
to extend its functionality. You can't write new Gherkin steps in Gherkin.
(Again, technically the last sentence is wrong. You <em>can</em> do that but you'd have
to implement it yourself and Gherkin won't help you.)</p>
<h2 id="overtaken-by-a-pdp-6">overtaken by a PDP-6</h2>
<p>The <a href="http://hci.stanford.edu/~winograd/shrdlu/">shrdlu</a> program was much ahead of
its time, and I'm not saying that its approach to natural language understanding
would have been a good one for Gherkin to take in general.</p>
<p>However, at least one feature would be an obvious improvement to Gherkin,
and not that hard to implement: The whole notation of context.</p>
<pre><code>When I type &quot;foo&quot; into the password box
Then it should change its color to red
And next to it &quot;Your password is too short&quot; should appear.
</code></pre>
<p>You <em>can</em> do something like that in Gherkin today but you'd have to implement
it yourself. Which might not be that surprising at this point. Gherkin does
almost nothing - Gherkin <em>is</em> almost nothing.</p>
<p>It's just a small hack.</p>
<h2 id="bonus">bonus</h2>
<p>Here's an implementation of the core of Gherkin in ~30 lines of Racket:</p>
<pre><code>#lang racket

(define *steps* '())
(define-syntax-rule (prepend! l x) (set! l (cons x l)))
(define-syntax-rule (Given r (args ...) body ...)
  (prepend! *steps* (cons (regexp r)
                          (lambda (full-match args ...) (begin body ...)))))
(define-syntax-rule (Then r (args ...) body ...) (Given r (args ...) body ...))
(define-syntax-rule (When r (args ...) body ...) (Given r (args ...) body ...))

(define (trim-step step)
  (regexp-replaces (string-trim step)
                   '([#rx&quot;^(Given|And|Then|When) &quot; &quot;&quot;])))

(define (match-step s r) (regexp-match r (trim-step s)))

(define (find-step s)
  (define found (findf (compose (curry match-step s) car) *steps*))
  (if found
    (values (car found) (cdr found))
    (values #f #f)))

(define (run-step step)
  (displayln step)
  (define-values (step-regexp step-fn) (find-step step))
  (if step-fn
    (with-handlers ([exn:fail? (lambda (e) (printf &quot;FAILED: ~a\n&quot; (exn-message e)))])
      (apply step-fn (match-step step step-regexp)))
    (printf &quot;\tStep not implemented. Implement with something like:\n\t~s\n\n&quot;
      `(Given ,(trim-step step) () (do whatever)))))

(define (run-feature f) (for-each run-step (string-split f &quot;\n&quot;)))
</code></pre>
<p>Step implementations would look like this:</p>
<pre><code>;;; utilities
(require net/url)
(define *content* &quot;&quot;)
(define (GET url)
  (call/input-url (string-&gt;url url) get-pure-port
    (lambda (p) (set! *content* (port-&gt;string p)))))

;;; steps

(Given &quot;^I am on '([^']*)'$&quot; (url) (GET url))

(Then &quot;^I should see '([^']*)'$&quot; (text)
  (unless (regexp-match? (regexp text) *content*)
    (error &quot;Text not found&quot;)))
</code></pre>
<p>And you'd run it like this:</p>
<pre><code>-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
   Then I should see 'Example Domain'
&quot;)

Given I am on 'http://example.com'
 Then I should see 'Example Domain'

-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
   Then I should see 'Foobar'
&quot;)

Given I am on 'http://example.com'
 Then I should see 'Foobar'
FAILED: Text not found

-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
  Then everything should work
&quot;)

Given I am on 'http://example.com'
Then everything should work
    Step not implemented. Implement with something like:
    (Given &quot;everything should work&quot; () (do whatever))
</code></pre>
<p>It's just a hack. A nice one, maybe - but just a hack nonetheless.</p>

    </main>
  </body>
</html>
