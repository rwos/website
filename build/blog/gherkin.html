<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0">
    <meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning.">
    <title>Given When Then | r-wos.org</title>
    <style>
    * { line-height: 140%; }
    body { margin:15px auto; max-width:40em; padding: 0 1em; }
    body { background: lightcyan; }
    nav, main, aside { background: white; border: 4px ridge black; padding: 8px 1em; margin: 8px 0; }
    nav { background: lightyellow; }
    h1 { text-align: center; color: rebeccapurple; }
    time { background: yellow }
    {% include blink.css %}
    </style>
  </head>
  <body>
    <nav>
      <img style="vertical-align: middle" src="/media/disk.gif">
      <a href="/">Home</a> -
      <a href="/blog">Blog</a> -
      <a href="/feed.xml">RSS</a> -
      <a href="/hacks">Hacks</a> -
      <a href="/about">About</a>
    </nav>
    <main>
      <h1>Given When Then</h1>
      <p><b><time datetime="2013-10-27 00:00:00 &#43;0000">2013-10-27 00:00:00 &#43;0000</time></b></p>
      <p><a href="https://github.com/cucumber/cucumber/wiki/Gherkin">Gherkin</a> is a hack.</p>
<p>Gherkin is the &quot;language&quot; (I'll justify the use of scare-quotes in a minute)
used by the <a href="https://github.com/cucumber/cucumber">Cucumber</a> test framework.
Or, if you're using PHP, the language behind the PHP port <a href="http://behat.org/">behat</a>.</p>
<p>Tests usually look something like this (example lifted straight from cucumber's docs):</p>
<pre><code>Feature: Serve coffee
  In order to earn money
  Customers should be able to 
  buy coffee at all times

  Scenario: Buy last coffee
    Given there are 1 coffees left in the machine
    And I have deposited 1$
    When I press the coffee button
    Then I should be served a coffee
</code></pre>
<p>Which <em>is</em> very nice. Having tests that are as easily readable as this
is obviously fantastic!</p>
<p>What is not nice is how it's implemented. What is even less nice, is how it's
sold as a &quot;business readable, domain specific language&quot;. I can live very well
with crude hacks, as long as the README states &quot;it's a crude hack&quot;. Glancing
over obvious limitations in exchange for marketing slogans bothers me, however.
Among programmers, we should be honest first.</p>
<h2 id="intro">intro</h2>
<p>Let's step through the test above:</p>
<pre><code>Feature: Serve coffee
  In order to earn money
  Customers should be able to 
  buy coffee at all times
</code></pre>
<p>This whole block is just a comment and subsequently ignored. You have to
have one of those at the top of your files, and the block below <code>Feature</code> has
to be indented, however.</p>
<pre><code>  Scenario: Buy last coffee
</code></pre>
<p>Another comment. Now comes the actual executable code:</p>
<pre><code>Given there are 1 coffees left in the machine
And I have deposited 1$
When I press the coffee button
Then I should be served a coffee
</code></pre>
<p>Every line here is a &quot;step&quot;, and every step does something.</p>
<h2 id="assertions-and-instructions">assertions and instructions</h2>
<p>Even thought there are semantic differences between sentences beginning with
with <code>Given</code>, <code>When</code>, and <code>Then</code> in English, they are all the same thing in Gherkin.</p>
<p>Suppose the first sentence</p>
<pre><code>Given there are 1 coffees left in the machine
</code></pre>
<p>sets up the machine to have 1 coffees [sic!] left. You start to run into problems
once you now write a different test where the <em>outcome</em> should be that the
machine has one coffee left. Say, something like this:</p>
<pre><code>Given there are 2 coffees left in the machine
When I order one coffee
Then there are 1 coffees left in the machine.
</code></pre>
<p>Perfectly reasonable for a human, but for Gherkin this translates to:</p>
<pre><code>set up the machine to have 2 coffees left
order one coffee
set up the machine to have 1 coffee left
</code></pre>
<p>Which is not only not right, it's not even wrong. This test will
run and it will run <em>successfully</em> every time.</p>
<p>What Gherkin wants you to write is something like this:</p>
<pre><code>Given there are 2 coffees left in the machine
When I order one coffee
Then there should be 1 coffees left in the machine.
</code></pre>
<p>So that the programmers can implement the &quot;there should be&quot; sentence as an assertion,
and the &quot;there are&quot; sentence as a instruction. Why is this difference not
handled via the <code>Given</code>/<code>Then</code> keywords? Who knows.</p>
<p>This minimalism/stupidity in Gherkin's approach to parsing results in a
programming language with extremely low orthogonality. In fact, there's none at
all. If you come across a step like</p>
<pre><code>Given there are 1 coffees left in the machine
</code></pre>
<p>this does <em>not</em> guarantee at all that</p>
<ul>
<li>there's a step <code>Given there are 2 coffees left in the machine</code></li>
<li>there's a step <code>Given there are 1 cappuccinos left in the machine</code></li>
<li>there's a step <code>Then there should be 1 coffees left in the machine</code></li>
<li>and so on</li>
</ul>
<p>I think this is pretty confusing, <em>especially</em> for non-programmers.
Also, depending on how you write your regexps, the step above is distinct from
all of the following:</p>
<ul>
<li>Given there are 1 coffees  left in the machine</li>
<li>Given there are 1 coffees left in the machine.</li>
<li>Given there are 1 coffees left in the machine!</li>
<li>Given there are 1 coffee left in the machine</li>
<li>Given there is 1 coffee left in the machine</li>
<li>Given there is one coffee left in the machine</li>
<li>Given there are 1 coffees left</li>
<li>and so on</li>
</ul>
<p>This is easily traceable back to the simplistic implementation, but that doesn't
help anyone. Gherkin is aimed at non-technical folk - and it's syntactically
<em>less</em> forgiving than JavaScript! In terms of human-friendliness of the
syntax it's comparable to the older fixed-format versions of FORTRAN.</p>
<p>In other words: Gherkin is (or can be) nice to read, but it's <em>extremely</em>
unfriendly to write.</p>
<h2 id="2-problems">2 problems</h2>
<p>Let's talk about the implementation. Gherkin is regexp-based
<strike>because that's an absolutely reasonable choice for parsing a natural language</strike>.</p>
<p>So, for every &quot;step&quot;, you have a regexp with some code behind it, that implements
this step. It looks something like this (in cucumber, behat is a bit more verbose):</p>
<pre><code>Given /I have deposited (\d+)\$/ do |n|
    @machine.deposit(n)
end
</code></pre>
<p>In other words: there is no Gherkin language. At all. Gherkin is a lexical scanner,
nothing more. The parser (regexps) and evaluator (associated code) is solely in
your hands to implement. And because Gherkin limits you to per-line regexps,
the resulting Gherkin-based DSL is <em>less</em> capable than pretty much anything
you could've come up with yourself.</p>
<p>In behat at least (I assume it's the same in cucumber), there's also no way to
stack regexps. Every step has to match exactly <em>one</em> regexp.  What that means
is that you can't special-case steps, and you can't override them. (Well, you
can, but it's extremely hacky).</p>
<p>There are other limitations: It's not possible to use the &quot;language&quot; itself
to extend its functionality. You can't write new Gherkin steps in Gherkin.
(Again, technically the last sentence is wrong. You <em>can</em> do that but you'd have
to implement it yourself and Gherkin won't help you.)</p>
<h2 id="overtaken-by-a-pdp-6">overtaken by a PDP-6</h2>
<p>The <a href="http://hci.stanford.edu/~winograd/shrdlu/">shrdlu</a> program was much ahead of
its time, and I'm not saying that its approach to natural language understanding
would have been a good one for Gherkin to take in general.</p>
<p>However, at least one feature would be an obvious improvement to Gherkin,
and not that hard to implement: The whole notation of context.</p>
<pre><code>When I type &quot;foo&quot; into the password box
Then it should change its color to red
And next to it &quot;Your password is too short&quot; should appear.
</code></pre>
<p>You <em>can</em> do something like that in Gherkin today but you'd have to implement
it yourself. Which might not be that surprising at this point. Gherkin does
almost nothing - Gherkin <em>is</em> almost nothing.</p>
<p>It's just a small hack.</p>
<h2 id="bonus">bonus</h2>
<p>Here's an implementation of the core of Gherkin in ~30 lines of Racket:</p>
<pre><code>#lang racket

(define *steps* '())
(define-syntax-rule (prepend! l x) (set! l (cons x l)))
(define-syntax-rule (Given r (args ...) body ...)
  (prepend! *steps* (cons (regexp r)
                          (lambda (full-match args ...) (begin body ...)))))
(define-syntax-rule (Then r (args ...) body ...) (Given r (args ...) body ...))
(define-syntax-rule (When r (args ...) body ...) (Given r (args ...) body ...))

(define (trim-step step)
  (regexp-replaces (string-trim step)
                   '([#rx&quot;^(Given|And|Then|When) &quot; &quot;&quot;])))

(define (match-step s r) (regexp-match r (trim-step s)))

(define (find-step s)
  (define found (findf (compose (curry match-step s) car) *steps*))
  (if found
    (values (car found) (cdr found))
    (values #f #f)))

(define (run-step step)
  (displayln step)
  (define-values (step-regexp step-fn) (find-step step))
  (if step-fn
    (with-handlers ([exn:fail? (lambda (e) (printf &quot;FAILED: ~a\n&quot; (exn-message e)))])
      (apply step-fn (match-step step step-regexp)))
    (printf &quot;\tStep not implemented. Implement with something like:\n\t~s\n\n&quot;
      `(Given ,(trim-step step) () (do whatever)))))

(define (run-feature f) (for-each run-step (string-split f &quot;\n&quot;)))
</code></pre>
<p>Step implementations would look like this:</p>
<pre><code>;;; utilities
(require net/url)
(define *content* &quot;&quot;)
(define (GET url)
  (call/input-url (string-&gt;url url) get-pure-port
    (lambda (p) (set! *content* (port-&gt;string p)))))

;;; steps

(Given &quot;^I am on '([^']*)'$&quot; (url) (GET url))

(Then &quot;^I should see '([^']*)'$&quot; (text)
  (unless (regexp-match? (regexp text) *content*)
    (error &quot;Text not found&quot;)))
</code></pre>
<p>And you'd run it like this:</p>
<pre><code>-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
   Then I should see 'Example Domain'
&quot;)

Given I am on 'http://example.com'
 Then I should see 'Example Domain'

-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
   Then I should see 'Foobar'
&quot;)

Given I am on 'http://example.com'
 Then I should see 'Foobar'
FAILED: Text not found

-&gt; (run-feature &quot;
  Given I am on 'http://example.com'
  Then everything should work
&quot;)

Given I am on 'http://example.com'
Then everything should work
    Step not implemented. Implement with something like:
    (Given &quot;everything should work&quot; () (do whatever))
</code></pre>
<p>It's just a hack. A nice one, maybe - but just a hack nonetheless.</p>

    </main>
  </body>
</html>
