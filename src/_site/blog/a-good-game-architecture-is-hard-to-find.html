<!doctype html><html lang="en"><head><meta http-equiv="Content-type" content="text/html;charset=UTF-8"><meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0"><meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning."><title>A Good Game Architecture Is Hard to Find | r-wos.org</title> <style>
    * { line-height: 140%; }
    @-moz-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@-webkit-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@-o-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@keyframes blink {
 0% {
    opacity: 1;
 }
 50% {
    opacity: 0;
 }
 100% {
    opacity: 1;
 }
}

blink {
  display: inline;
  -webkit-animation: blink 1s steps(1) infinite;
  -moz-animation: blink 1s steps(1) infinite;
  -o-animation: blink 1s steps(1) infinite;
  animation: blink 1s steps(1) infinite;
}

    </style></head><body style="margin:15px auto;max-width:40em"> <nav> <a href="/">Home</a> - <a href="/blog">Blog</a> - <a href="/feed.xml">RSS</a> - <a href="/hacks">Hacks</a> - <a href="/about">About</a> </nav> <main><h1>A Good Game Architecture Is Hard to Find</h1><p><time datetime="2012-05-16">2012-05-16</time></p><p>I’ve run head-first into the first big wall on my little OpenGL-Project.</p><p>I was implementing a simple physics system, which triggered a much bigger problem: the general architecture of my game was crap. I knew that, but I didn’t know how to make it suck less.</p><p>However, I <em>think</em> I have now found a solution.</p><p>The usual object-oriented approach to game architecture is to create a hierarchy of classes, from the most general (probably “GameObject”) to the most special case (“BlueAngryFlyingFlamethrowingDragon”).</p><p>Hierarchies like that are easy to understand and generally nice to look at. There’s just one small problem: they don’t work.</p><p>A hierarchy of game objects is first and foremost a lie. A beautiful lie, maybe, but a lie nonetheless. Every new major feature potentially re-shuffles the whole class-tree. Also, the whole approach inevitably leads to a stupid amount of work re-ordering things and pseudo-generalizing stuff into yet more classes. Refactoring is hard (it’s a hierarchy, you can’t just move stuff around as you wish) <em>and</em> incredibly important - because the only alternative to constant refactoring is “guessing everything just right at the first try”.</p><p>But if you’re trying to fit the whole world into a single hierarchy, getting it right the first time around is pretty much impossible. Just ask the <a href="http://en.wikipedia.org/wiki/Linnaean_taxonomy">Fungi</a>. Multiple inheritance <a href="http://en.wikipedia.org/wiki/Diamond_problem">doesn’t really help</a>, either.</p><p>So, OOP is out: too much work, too little gain, too brittle code.</p><p>Another major approach are entity-systems, which shift the attention away from the hierarchy and just concentrate everything around the so-called components instead.</p><p>The component (stupid name IMHO, I would’ve called it “feature”) holds the data for a small aspect of a game object. A “PhysicalComponent” for instance would probably hold things like position, velocity, mass, etc.</p><p>The entity is the actual game object - however, it’s just a container for components. If some game character needs to be able fly, it would just get a “FlyingComponent” added; if it needs to throw flames, it would get a “ThrowFlamesComponent” added - and so on.</p><p>The processing happens somewhere else - in the “systems”, which take the components and do stuff. (I haven’t found a more detailed description of what the systems should or shouldn’t do. Also, the data-flows are still quite a bit of a mystery to me.)</p><p>And - last but not least - there’s reactive programming, which basically works like a spreadsheet: All values have a formula associated with them, which is used to keep the value up to date when a dependency changes. Both the update and the dependency-resolution usually happen automatically. It’s not too wide-spread, I think, but there are libraries for at least Python and Common Lisp which implement this scheme.</p><p>What <em>I’m</em> currently trying to implement for my game is something like that component-entity thingy, but not as OOP-ish as most websites describe it. Until now, it seems to be a good fit: the data-flow into and out of the functions is explicit and clear. It’s a bit too verbose, but I think I can hide most of that behind some macros.</p><p>Today’s screenshot shows… fog! And spheres! Isn’t that nice? (as I said, I mostly wrestled with the architecture, lately)</p><p><img src="http://r-wos.org/media/game-4-1.png" style="width:90%"/></p><p>Also, here’s a diagram from the project’s repository. The x-axis shows the hour of the day, the y-axis shows the number of commits made at that hour. Just in case someone wondered what having a semi-complex side-project and a 40 hour work week does to your sleep cycle. ;-)</p><p><img src="http://r-wos.org/media/game-4-2.png" style="width:90%"/></p><p>Happy hacking!</p><hr><h2>See Also</h2><p>Previously: <a href="/blog/these-feet-are-made-for-walking">These feet are made for walking</a></p><p>Next up: <a href="/blog/purely-functional-games">Purely Functional Games</a></p><p> The machine thinks that the Web-Log entries <a href="/blog/a-good-game-architecture-is-hard-to-find">A Good Game Architecture Is Hard to Find</a>, <a href="/blog/purely-functional-games">Purely Functional Games</a>, and <a href="/blog/ludum-dare-26-postmortem">26th Ludum Dare - Postmortem</a> might be related to the topic so eloquently discussed above. The machine is sometimes right.</p></main></body></html>