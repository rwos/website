<!doctype html><html lang="en"><head><meta http-equiv="Content-type" content="text/html;charset=UTF-8"><meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0"><title>Pure Functional WTF | r-wos.org</title> <style>
    * { line-height: 140%; }
    @-moz-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@-webkit-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@-o-keyframes blink {
 0% {
   opacity: 1;
 }
 50% {
   opacity: 0;
 }
 100% {
   opacity: 1;
 }
}

@keyframes blink {
 0% {
    opacity: 1;
 }
 50% {
    opacity: 0;
 }
 100% {
    opacity: 1;
 }
}

blink {
  display: inline;
  -webkit-animation: blink 1s steps(1) infinite;
  -moz-animation: blink 1s steps(1) infinite;
  -o-animation: blink 1s steps(1) infinite;
  animation: blink 1s steps(1) infinite;
}

    </style></head><body style="margin:15px auto;max-width:40em"> <nav> <a href="/">Home</a> - <a href="/blog">Blog</a> - <a href="/feed.xml">RSS</a> - <a href="/hacks">Hacks</a> - <a href="/about">About</a> </nav> <main><h1>Pure Functional WTF</h1><p>2011-10-23<p>I watched a couple of talks from Rich Hickey recently. (To be precise: <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">this talk</a> and <a href="http://www.infoq.com/presentations/Simple-Made-Easy">this one</a>.)</p><p>He is the creator of <a href="http://clojure.org">Clojure</a>, a Lisp for the JVM and the CLI (the .NET system). Well, actually, Clojure is not only <em>some</em> Lisp, but a more modern, more functional Lisp dialect.</p><p>Clojure is based on immutable types, like other pure-functional languages.</p><p>This was a foreign concept for me. And it doesn’t seem very helpful at first. You can’t change things. You have to produce a new version, with the “changes” included. Now, clojure makes this faster than it sounds, using some heavy trie wizardry (yes, <a href="http://en.wikipedia.org/wiki/Trie">trie</a>, not tree) - but that’s not the point.</p><p>The point is - that whole concept makes sense. You can stop worrying about the state of a data structure. The thing you got will never change. It can’t. It’s save to dereference, and it always will be.</p><p>Additionally, and derived from that, everything becomes time-independent. As long as you apply the same functions in the same order on the same data, you will always get the same result.</p><p>That’s functional programming and that’s all fun and games. I can easily see that this works great for any sort of compiler or translator or programs of that kind.</p><p>But it doesn’t really work for processes; for programs where you <em>want</em> changes over time, or for any kind of I/O.</p><p>And that is the point where it gets tricky. Now you’ve got to manage time. And you’ve got to manage side-effects. That’s where things like “monads” enter the stage.</p><p>Rich Hickey talked about the difference between “simple” and “easy” - and doing I/O via monads is one of the things, where - for me - it becomes too hard to do the simple.</p><p>I just don’t grok it. When I read sentences like this:</p><blockquote><p>An additive monad is a monad endowed with a monadic zero and an operation (called mplus) satisfying the monoid laws, with the monadic zero as unit. The operation has type M t -&gt; M t -&gt; M t (where M is the monad constructor and t is the underlying data type), satisfies the associative law and has the zero as both left and right identity. (Thus, an additive monad is also a monoid.)</p></blockquote><p>my brain switches into “overload” mode. I get a SIGSEGV from only <em>trying</em> to understand what this might be about.</p><p>How can simple things be so hard?</p><p>In some regards, this reminds me of my first encounter with object-oriented programming. I thought “WTF is this about? Why can’t they just, you know, <em>program</em> like normal people?”. But I <em>did</em> understand OOP, eventually. I don’t know how, but one day the light bulb went on.</p><p>I really hope that happens with monads, too.</p><p>This cannot not be as hard as it looks, right?</p><hr><h2>See Also</h2><p>Previously: <a href="/blog/the-dark-side">The Dark Side</a></p><p>Next up: <a href="/blog/lifelong-learning">Lifelong Learning</a></p><p> The machine thinks that the Web-Log entries <a href="/blog/pure-functional-wtf">Pure Functional WTF</a>, <a href="/blog/purely-functional-games">Purely Functional Games</a>, and <a href="/blog/ludum-dare-26-postmortem">26th Ludum Dare - Postmortem</a> might be related to the topic so eloquently discussed above. The machine is sometimes right.</p></main></body></html>