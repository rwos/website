<!doctype html><html lang="en"><head><meta http-equiv="Content-type" content="text/html;charset=UTF-8"><meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0"><meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning."><title>Purely Functional Games | r-wos.org</title> <style>
    * { line-height: 140%; }
    body { margin:15px auto; max-width:40em; padding: 0 1em; }
    @-moz-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@-webkit-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@-o-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}blink{display:inline;-webkit-animation:blink 1s steps(1) infinite;-moz-animation:blink 1s steps(1) infinite;-o-animation:blink 1s steps(1) infinite;animation:blink 1s steps(1) infinite}

    </style></head><body> <nav> <a href="/">Home</a> - <a href="/blog">Blog</a> - <a href="/feed.xml">RSS</a> - <a href="/hacks">Hacks</a> - <a href="/about">About</a> </nav> <main><h1>Purely Functional Games</h1><p><b><time datetime="2012-05-25">2012-05-25</time></b></p><p>First things first: <strong>What is purely functional programming?</strong></p><p>A simple definition that’ll do it for this exercise is this:</p><ul><li><p>It’s called “functional”, because we use functions. Functions get arguments passed into them; do something with those arguments; and eventually return a result.</p></li><li><p>It’s called “pure”, because we only use functions without side-effects - calling the function with the same value always leads to the same result. Thus, functions are generally not allowed to change something outside of their scope, be it global variables or memory or files, etc.</p></li></ul><p>As you can see from this definition, we can never do IO, never directly allocate memory, never write to files, never receive user input - which is quite a bit of a problem for a game, isn’t it?</p><p>That’s why I trade a bit of the pureness for some practicality. I <em>am</em> receiving user input, and I <em>am</em> sending things to the GPU. The whole <em>game</em>, the vast majority of the code is everything between those two, of course - and that’s where I try to keep things pure.</p><p>And guess what - I’ll still call the whole thing “purely functional”, even if it isn’t.</p><p>Second things second (well…): <strong>Why would one want to do this?</strong></p><ul><li>to ease testing</li></ul><p>Unit testing in a purely functional program is easy - just pass in the right data and test if the return value is what you expected. That’s it. There’s - by definition - no set-up or tear-down or other complicated crap needed.</p><ul><li>to ease programming</li></ul><p>For the same reasons purely functional programs are trivial to unit-test, they are easy to reason about - one function at a time.</p><p>Of course, that doesn’t mean that all purely functional programs are easy to <em>understand</em> (as in “anyone could immediately understand what this code does”). Far from it - I personally find the typical purely functional programs <em>harder</em> to grok than the typical C or Java program. The important part is that <em>when</em> you understand all the parts of a purely functional program, you <em>by definition</em> do understand the whole program. Whereas in side-effect-rich programs, in order to really understand what’s going on, one basically has to have a CPU and half a gig of RAM in one’s head.</p><ul><li>because it hasn’t been done before</li></ul><p>Now, there <em>are</em> purely functional games, but there aren’t many of them. It’s still such a novelty that many games written in that style advertise the fact. (Well, on the other hand: if they didn’t advertise it I wouldn’t know about it, so… yeah.)</p><p>And there <em>are</em> some resources - but mostly, you’re on your own.</p><p>And that’s fun, isn’t it?</p><ul><li>because it’s fun</li></ul><p>Yes, it is.</p><p>So - <strong>How does it work for games?</strong></p><p>Short version: it’s quite a challenge.</p><p>Long version:</p><p>Let’s start at the basics, shall we? The most high-level loop in a game generally looks like this:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forever do:
    receive user input
    update the game world
    draw the world to the screen
</code></pre></div></div><p>As I’ve said above, doing that loop in a purely functional style is out of my scope. So, let’s take a look at “update the game world”: This block consists of many functions, small and big - all mutating the state of the world.</p><p>Well, they would do exactly that in an object-oriented or imperative program, but in a purely functional program, we can’t use side effects. We can’t just change the world</p><ul><li>we can only take the old world and return a new one.</li></ul><p>Now, that would be mighty ugly - every single little function takes the whole world and returns a whole <em>new</em> world? It would maybe look a bit like this:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let* ((w1 (update-npc-stats    world))
       (w2 (update-player-stats w1))
       (w3 (update-physics      w2)))
  ;;; w3 now is the world we'll pass to the renderer
  [...]
</code></pre></div></div><p>What’s the point of doing that? What would be the advantage over directly manipulating the world? That’s a rhetorical question, there is none.</p><p>One solution to this mess would be to only pipe the actual parts of the world that’ll get “updated” to the functions - and re-create a new world outside of them.</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let ((w1 (new-world-with-changes world
            'npc-stats
            (update-npc-stats (world-npc world)))))
  [...]
</code></pre></div></div><p>I tried that, but beside not knowing how to name most things and functions (always a bad sign), it was really really ugly and noisy and verbose. Again, that would’ve been far easier to write and look cleaner in imperative style</p><ul><li>so, not good.</li></ul><p>One <em>real</em> solution that I found <a href="http://prog21.dadgum.com/26.html">on the net</a> is to not concentrate on the <em>world</em> at all. What all these little functions really produce are neither new worlds nor new positions or velocities - they produce <em>changes</em>. That is, descriptions of things that will happen. Actually <em>doing</em> those things (i.e. producing a new world, with some objects on different positions, or in different colors or something) is a completely separate step.</p><p>I have recently implemented some system based on that idea in my little not-yet-a-game-game and it works just great. I really doubt I could’ve come up with something of that elegance all by myself - but that’s what the internet is for, right?</p><p>Now that all those functions just return changes, we can easily collect their output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(let ((npc-changes    (map update-npc-stats (world-npcs       world)))
      (physics        (map update-physics   (world-particles  world)))
      (player-changes (list (player-points time)
                            (update-player-stats world))))
;;; dozens of other forms would be possible, too
;;; (this is not real code, by the way, but it's close)
</code></pre></div></div><p>We still have the problem of threading stuff <em>into</em> the functions (and I still don’t have a real solution for that - one can basically choose between “overly verbose” and “overly opaque”, both non-optimal) - but that’s now decoupled from the problem of collecting the output.</p><p>So, to answer the last question everyone probably has now:</p><p><strong>What the fuck?</strong></p><p>Yeah, I didn’t say it was easy. Also, I don’t know if I’m just very stupid, or this is very hard, or I’m doing something very wrong, or purely functional programming is just not a good fit for games, or if we all should just go shopping.</p><p>But I do enjoy it, actually - it doesn’t have to be easy. Games are hard to write. Good code is hard to write. Writing a game using only good code is hard².</p><p>A good purely functional game? Hard!</p><hr/><p>Only tangentially related to today’s post, the following screencast shows my first try of a collision engine. It’s a slowed-down version of a simulation that ran on pretty high (that is, earth-like) gravity settings. The spheres are two meters in diameter and weight 10kg each. You’ll notice that at one point two spheres pass right through each other. You’ll also notice the low and unstable frame-rate. These are the things I currently try to resolve with my second try of a collision engine…</p><p>But that’s stuff for another post.</p><p><img src="http://r-wos.org/media/game-5-1.gif" style="width:90%"/></p><p>Good night and happy hacking!</p><hr><h2>See Also</h2><p>Previously: <a href="/blog/a-good-game-architecture-is-hard-to-find">A Good Game Architecture Is Hard to Find</a></p><p>Next up: <a href="/blog/php-explained">PHP explained</a></p><p> The machine thinks that the Web-Log entries <a href="/blog/ludum-dare-26-postmortem">26th Ludum Dare - Postmortem</a>, <a href="/blog/german-programming-apprenticeship-review">The German Programming Apprenticeship - A Review</a>, and <a href="/blog/test-driven">Test Driven Development</a> might be related to the topic so eloquently discussed above. The machine is sometimes right.</p></main></body></html>