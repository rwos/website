<!doctype html><html lang="en"><head><meta http-equiv="Content-type" content="text/html;charset=UTF-8"><meta name="Viewport" content="width=device-width,initial-scale=1,maximum-scale=1.0"><meta name="Description" content="Homepage of Richard Wossal. Weeks of hacking can save you hours of planning."><title>A Graphical Forever Project, Part 2 | r-wos.org</title> <style>
    * { line-height: 140%; }
    body { margin:15px auto; max-width:40em; padding: 0 1em; }
    body { background: lightcyan; }
    nav, main, aside { background: white; border: 4px ridge black; padding: 8px 1em; margin: 8px 0; }
    nav { background: lightyellow; }
    h1 { text-align: center; color: rebeccapurple; }
    time { background: yellow }
    @-moz-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@-webkit-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@-o-keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}@keyframes blink{0%{opacity:1}50%{opacity:0}100%{opacity:1}}blink{display:inline;-webkit-animation:blink 1s steps(1) infinite;-moz-animation:blink 1s steps(1) infinite;-o-animation:blink 1s steps(1) infinite;animation:blink 1s steps(1) infinite}

    </style></head><body> <nav> <img style="vertical-align:middle" src="/media/disk.gif"> <a href="/">Home</a> - <a href="/blog">Blog</a> - <a href="/feed.xml">RSS</a> - <a href="/hacks">Hacks</a> - <a href="/about">About</a> </nav> <main><h1>A Graphical Forever Project, Part 2</h1><p><b><time datetime="2013-02-15">2013-02-15</time></b></p><p><small>(<a href="http://r-wos.org/blog/forever-gui">part 1</a>)</small></p><p>My first idea of how we could simplify creating graphical user interfaces was to just take a unix pipe and to either render something graphical for each component, or only one input-element and one output element.</p><p>That is, for example <code class="highlighter-rouge">find ./ -name *.c | xargs grep -n "[^f]gets" | vi -</code> would result in a number of little boxes on the screen, connected by pipes, with the last box being <code class="highlighter-rouge">vi</code>. The <code class="highlighter-rouge">find</code> box may have had a text-field for the directory in it, and some (actually: much more) other widgets for controlling all the other options. As would the <code class="highlighter-rouge">xargs</code> box, and so on.</p><p>That would be very simple (<em>no</em> work at all to implement a GUI), but also very stupid.</p><p>The relationship between a program and its GUI is a bit funny. If you look at today’s GUI programs, you’ll find that there’s usually no connection at all between the structure of the program and the structure of the GUI. Which is fine, I think. With current graphics systems you are absolutely free to do the GUI whatever way you want.</p><p>So I came to the (not too surprising) conclusion that a graphics system has to have that distinction between GUI and program.</p><p>Currently, most GUIs are trees. It may be worthwhile to explore other means of grouping in GUIs, but as a whole the current parent-children approach seems to work rather well. The unix shell language can’t easily express trees. The unix file system can, however. So it seems rather natural to map containers (windows, group-boxes, tabs, …) to directories, and containees (buttons, text-fields, …) to files.</p><p>But creating complex file trees is cumbersome with the standard unix tools. Trees are, however, easy to express as s-expressions.</p><p>Putting it all together: say, we want a program that has takes a word, <a href="http://duckduckgo.com?q=define+hello">searches for the definition on duckduckgo</a>, and shows the result. If we were to run that program on the command line, we’d expect a plain-text answer. If we were to run it as a desktop application, we’d expect a little formatting.</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
word-input <span class="o">=</span> text-input <span class="nt">-name</span> word
gui-output <span class="o">=</span> html-render
http GET <span class="s2">"duckduckgo.com/q?=define+</span><span class="sb">`</span><span class="nv">$word</span><span class="nt">-input</span><span class="sb">`</span><span class="s2">"</span> | <span class="se">\</span>
    html only div <span class="nb">id</span><span class="o">=</span><span class="s2">"zero_click"</span> | <span class="nv">$gui</span><span class="nt">-output</span> | html2text
<span class="c"># (vertical</span>
<span class="c">#   word-input</span>
<span class="c">#   gui-output)</span>
</code></pre></div></div><p>If we had the utilities that I made up for this example, you could run that script today with any unix shell. <code class="highlighter-rouge">text-input</code> would just print the name and read your input, <code class="highlighter-rouge">http</code> would send the request and return the result, <code class="highlighter-rouge">html</code> would parse the html and return only the div with the id “zero_click”. <code class="highlighter-rouge">html-render</code> would do nothing and just return its input, and <code class="highlighter-rouge">html2text</code> actually exists and does what you’d expect.</p><p>The GUI part is the tree in the comments. A graphics system could parse the script including the “commented” section and create a window, with an input field and an HTML renderer below it.</p><p>One way to do that would be to implement a <code class="highlighter-rouge">-gui</code> switch on text-input and html-render which would make them return their graphical representation - and the GUI would know about that switch and call the elements of the window with it.</p><p>This seems all pretty hacky, and it is - but it would also mean that you’d have a GUI system on the shell-scripting level. The real benefit of that is the power you’d gain, when you go further and implement basically “higher-order” GUIs. Say we have a text-editor and want to add the ability to look up word definitions. Assuming we put the script above into <code class="highlighter-rouge">/bin</code>, maybe named “word-definition”, we could now just go ahead and include it into the GUI-tree of our text-editor.</p><p>The problem is, of course, that things don’t really work like that. Maybe you’d want the definition to pop up somewhere when you middle-click a word in the editor, or something like that. I don’t think that things like that (that is, real-world GUIs, as opposed to “what I wished GUIs looked like because it would make the programmer’s job easier”) are impossible to do with my little scheme, but it does take some thinking on how to do it elegantly.</p><p>At last, I want to come back to mapping GUIs to directories and files. I’m not sure whether or not this is a good idea (in fact, I’m leaning towards “this is absolutely stupid”), but it would have some good sides: You could <code class="highlighter-rouge">cp</code> or <code class="highlighter-rouge">mv</code> complete windows, or parts of windows elsewhere (maybe to another desktop). You could re-arrange windows by re-arranging the file hierarchy. You could share windows over a network, just as you can with files.</p><p>Hoverer, I haven’t really thought that through, yet. What kind of format would the files have? PNGs? Some formatted text? Binary bitmaps? And who would create them? And how would updating (i.e re-drawing) work if you could move them around as you wish? No idea.</p><p>It’s a Forever Project, after all.</p><hr><h2>See Also</h2><p>Previously: <a href="/blog/forever-gui">A Graphical Forever Project</a></p><p>Next up: <a href="/blog/make-frp-mainstream">Make FRP Mainstream!</a></p><p> The machine thinks that the Web-Log entries <a href="/blog/forever-gui-2">A Graphical Forever Project, Part 2</a>, <a href="/blog/ludum-dare-26-postmortem">26th Ludum Dare - Postmortem</a>, and <a href="/blog/purely-functional-games">Purely Functional Games</a> might be related to the topic so eloquently discussed above. The machine is sometimes right.</p></main></body></html>